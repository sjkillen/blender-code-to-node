"""
Invokes the parser generated by NodeCode.g4 and constructs an abstract syntax tree
"""

from dataclasses import dataclass
from enum import Enum, auto
from functools import partial
from itertools import chain

from antlr4 import ParseTreeVisitor, InputStream, CommonTokenStream
from grammar.NodeCodeLexer import NodeCodeLexer
from grammar.NodeCodeParser import NodeCodeParser

data = dataclass(frozen=True)


class SymbolTable:
    def __init__(self) -> None:
        self.inputs = dict()
        self.outputs = dict()
        self.bares = dict()

    def add_input(self, name: str):
        if name in self.outputs:
            raise Exception(
                f"variable {name} is already an output variable. Cannot be input"
            )
        if name in self.bares:
            del self.bares[name]
        self.inputs[name] = None

    def add_output(self, name: str):
        if name in self.inputs:
            raise Exception(
                f"variable {name} is already an input variable. Cannot be output"
            )
        if name in self.bares:
            del self.bares[name]
        self.outputs[name] = None

    def add_bare(self, name: str):
        if name in self.inputs or name in self.outputs:
            return
        self.bares[name] = None

    def is_bare(self, name: str) -> bool:
        return name in self.bares

    def is_input(self, name: str) -> bool:
        return name in self.inputs

    def is_output(self, name: str) -> bool:
        return name in self.outputs

    def __getitem__(self, name: str) -> "Expr":
        if self.is_input(name):
            raise Exception("Cannot lookup input variables")
        return self.bares[name] if self.is_bare(name) else self.outputs[name]

    def __setitem__(self, name: str, value: "Expr"):
        if self.is_input(name):
            raise Exception("Cannot set input variables")
        (self.bares if self.is_bare(name) else self.outputs)[name] = value


class Qualifier(Enum):
    IN = auto()
    OUT = auto()
    BARE = auto()

    def text(self):
        if self is Qualifier.IN:
            return "input "
        elif self is Qualifier.OUT:
            return "output "
        else:
            return ""


@data
class Expr:
    def walk_all_type(self, expr_type):
        if isinstance(self, UnaryExpr):
            yield from self.expr.walk_all_type(expr_type)
        elif isinstance(self, BinaryExpr):
            yield from self.left.walk_all_type(expr_type)
            yield from self.right.walk_all_type(expr_type)
        elif isinstance(self, FuncInvoke):
            yield from chain.from_iterable(
                expr.walk_all_type(expr_type) for expr in self.args
            )
        elif isinstance(self, Assignment):
            yield from self.expr.walk_all_type(expr_type)
        elif isinstance(self, Program):
            yield from chain.from_iterable(
                assignment.walk_all_type(expr_type) for assignment in self.stmts
            )

        if isinstance(self, expr_type):
            yield self

    def walk_all(self):
        yield from self.walk_all_type(Expr)

    def transform(self, transform):
        Cls = type(self)
        if isinstance(self, UnaryExpr):
            return transform(
                Cls(
                    op=self.op,
                    expr=self.expr.transform(transform),
                )
            )
        elif isinstance(self, BinaryExpr):
            return transform(
                Cls(
                    op=self.op,
                    left=self.left.transform(transform),
                    right=self.right.transform(transform),
                )
            )
        elif isinstance(self, FuncInvoke):
            return transform(
                Cls(
                    name=self.name,
                    args=tuple(expr.transform(transform) for expr in self.args),
                )
            )
        elif isinstance(self, Assignment):
            return transform(
                Assignment(
                    qualifier=self.qualifier,
                    id=self.id,
                    expr=self.expr.transform(transform)
                    if self.expr is not None
                    else None,
                )
            )
        elif isinstance(self, Program):
            return transform(
                Program(
                    stmts=tuple(
                        result
                        for assignment in self.stmts
                        if (result := assignment.transform(transform)) is not None
                    )
                )
            )
        elif isinstance(self, Constant) or isinstance(self, VarExpr):
            return transform(self)
        else:
            raise Exception("Unknown Expr", self)

    def transform_type(self, transform, expr_type):
        return self.transform(
            lambda expr: transform(expr) if isinstance(expr, expr_type) else expr
        )


@data
class FuncInvoke(Expr):
    name: str
    args: tuple[Expr]

    def text(self):
        args = ", ".join(arg.text() for arg in self.args)
        return f"{self.name}({args})"


@data
class Constant(Expr):
    pass


@data
class Number(Constant):
    value: str

    def text(self):
        return self.value


@data
class VarExpr(Expr):
    id: str

    def text(self):
        return self.id


@data
class UnaryExpr(Expr):
    op: str
    expr: Expr

    def text(self):
        return f"({self.op} {self.expr.text()})"


@data
class BinaryExpr(Expr):
    op: str
    left: Expr
    right: Expr

    def text(self):
        return f"({self.left.text()} {self.op} {self.right.text()})"


@data
class Assignment(Expr):
    qualifier: Qualifier
    id: str
    expr: Expr

    def text(self):
        body = f" = {self.expr.text()}" if self.expr is not None else ""
        return f"{self.qualifier.text()}{self.id}{body}"


@data
class Program(Expr):
    stmts: tuple[Assignment]

    def text(self):
        return "\n".join(a.text() for a in self.stmts)


@data
class UnaryNeg(UnaryExpr):
    pass


@data
class UnaryNot(UnaryExpr):
    pass


@data
class LtBinaryExpr(BinaryExpr):
    pass


@data
class GtBinaryExpr(BinaryExpr):
    pass


@data
class LeBinaryExpr(BinaryExpr):
    pass


@data
class GeBinaryExpr(BinaryExpr):
    pass


@data
class PowBinaryExpr(BinaryExpr):
    pass


@data
class AddBinaryExpr(BinaryExpr):
    pass


@data
class SubBinaryExpr(BinaryExpr):
    pass


@data
class EqBinaryExpr(BinaryExpr):
    pass


@data
class NeqBinaryExpr(BinaryExpr):
    pass


@data
class MulBinaryExpr(BinaryExpr):
    pass


@data
class DivBinaryExpr(BinaryExpr):
    pass


@data
class ModBinaryExpr(BinaryExpr):
    pass


class NodeCodeVisitor(ParseTreeVisitor):
    def __init__(self):
        self.symbols = SymbolTable()

    def visitProgram(self, ctx: NodeCodeParser.ProgramContext):
        return Program(
            stmts=tuple(self.visit(assignment) for assignment in ctx.assignment())
        )

    def visitQualifier(self, ctx: NodeCodeParser.QualifierContext):
        q = ctx.getText()
        if q not in ("input", "output"):
            raise Exception(f"Unknown qualifier {q}")
        return {
            "input": Qualifier.IN,
            "output": Qualifier.OUT,
        }[q]

    def visitAssignment(self, ctx: NodeCodeParser.AssignmentContext):
        qualifier = self.visit(ctx.qualifier()) if ctx.qualifier() else Qualifier.BARE
        name = str(ctx.IDENTIFIER())
        if qualifier is Qualifier.IN:
            self.symbols.add_input(name)
        elif qualifier is Qualifier.OUT:
            self.symbols.add_output(name)
        elif qualifier is Qualifier.BARE:
            self.symbols.add_bare(name)
        expr = self.visit(ctx.expr()) if ctx.expr() else None
        return Assignment(
            qualifier=qualifier,
            id=name,
            expr=expr,
        )

    def visitNeg(self, ctx: NodeCodeParser.NegContext):
        return UnaryNeg(op="-", expr=self.visit(ctx.expr()))

    def visitFunc(self, ctx: NodeCodeParser.FuncContext):
        return FuncInvoke(
            name=str(ctx.IDENTIFIER()),
            args=tuple(self.visit(expr) for expr in ctx.expr()),
        )

    def visitLnot(self, ctx: NodeCodeParser.LnotContext):
        return UnaryNot(op="!", expr=self.visit(ctx.expr()))

    def visitVar(self, ctx: NodeCodeParser.VarContext):
        return VarExpr(id=str(ctx.IDENTIFIER()))

    def visitNum(self, ctx: NodeCodeParser.NumContext):
        return Number(value=ctx.getText())

    def visitParenth(self, ctx: NodeCodeParser.ParenthContext):
        return self.visit(ctx.expr())

    def visitLt_gt_le_ge(self, ctx: NodeCodeParser.Lt_gt_le_geContext):
        op = ctx.op.text
        Constructor = {
            "<": LtBinaryExpr,
            ">": GtBinaryExpr,
            "<=": LeBinaryExpr,
            ">=": GeBinaryExpr,
        }[op]
        left, right = (self.visit(expr) for expr in ctx.expr())
        return Constructor(op=op, left=left, right=right)

    def visitPow(self, ctx: NodeCodeParser.PowContext):
        left, right = (self.visit(expr) for expr in ctx.expr())
        return PowBinaryExpr(op="**", left=left, right=right)

    def visitAdd_sub(self, ctx: NodeCodeParser.Add_subContext):
        op = ctx.op.text
        Constructor = {
            "+": AddBinaryExpr,
            "-": SubBinaryExpr,
        }[op]
        left, right = (self.visit(expr) for expr in ctx.expr())
        return Constructor(op=op, left=left, right=right)

    def visitEq_ne(self, ctx: NodeCodeParser.Eq_neContext):
        op = ctx.op.text
        Constructor = {
            "==": EqBinaryExpr,
            "!=": NeqBinaryExpr,
        }[op]
        left, right = (self.visit(expr) for expr in ctx.expr())
        return Constructor(op=op, left=left, right=right)

    def visitMul_div_mod(self, ctx: NodeCodeParser.Mul_div_modContext):
        op = ctx.op.text
        Constructor = {
            "*": MulBinaryExpr,
            "/": DivBinaryExpr,
            "%": ModBinaryExpr,
        }[op]
        left, right = (self.visit(expr) for expr in ctx.expr())
        return Constructor(op=op, left=left, right=right)


def remove_empty_vars(symbols: SymbolTable, assignment: Assignment):
    if assignment.expr is None:
        return None
    if symbols.is_input(assignment.id):
        raise Exception("Input vars cannot be assigned to")
    return assignment


def parse(text: str) -> tuple[SymbolTable, Program]:
    input_stream = InputStream(text)
    lexer = NodeCodeLexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = NodeCodeParser(stream)
    tree = parser.program()
    visitor = NodeCodeVisitor()
    program = visitor.visit(tree)
    return visitor.symbols, program.transform_type(
        partial(remove_empty_vars, visitor.symbols), Assignment
    )


def test():
    example = """
    input a
    output b
    g = 42 * bob + hi(a <= 6, b >= 9, hello.world == fun != lol)
    output u = g**69
    """
    example2 = """
    g = ((11)) ** 2 / 42 * bob + hi(a <= 6, b >= (9 + 1) * 7, hello.world == fun != lol)
    output u = g**69
    """
    symbols, program = parse(example)
    assert symbols.is_input("a")
    print(program.text())
    _, program = parse(example2)
    _, program2 = parse(program.text())
    assert program == program2
    print(program2.text())


import sys

if __name__ == "__main__" and not sys.flags.interactive:
    test()
    print("Tests passed :)")
